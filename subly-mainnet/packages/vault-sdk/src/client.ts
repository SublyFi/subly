import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  Signer,
} from "@solana/web3.js";
import { Program, AnchorProvider, BN, Idl, Wallet } from "@coral-xyz/anchor";
import {
  ShieldPool,
  UserShare,
  DepositParams,
  WithdrawParams,
  SetupRecurringPaymentParams,
  BalanceResult,
  YieldInfo,
  TransactionResult,
  VaultSdkConfig,
  PROGRAM_ID,
  INTERVAL_SECONDS,
  USDC_DECIMALS,
} from "./types";
import {
  getShieldPoolPda,
  getUserSharePda,
  getDepositHistoryPda,
  getScheduledTransferPda,
  getNullifierPda,
} from "./utils/pda";
import { generateCommitment, generateSecret, generateNullifier } from "./utils/commitment";
import {
  createPlaceholderEncryptedShare,
  readPlaceholderShares,
  KEY_DERIVATION_MESSAGE,
} from "./utils/encryption";

// Import IDL type (will be generated by anchor build)
import type { SublyVault } from "./idl/subly_vault";

/**
 * SublyVaultClient - Main SDK client for interacting with the Subly Vault program
 *
 * Provides methods for:
 * - Depositing USDC into the privacy pool
 * - Withdrawing USDC privately
 * - Setting up and managing recurring payments
 * - Checking balances and yield information
 */
export class SublyVaultClient {
  private connection: Connection;
  private wallet: Wallet;
  private program: Program<SublyVault> | null = null;
  private programId: PublicKey;
  private config: VaultSdkConfig;

  // Cached data
  private userSecret: Uint8Array | null = null;
  private userCommitment: Uint8Array | null = null;

  constructor(
    connection: Connection,
    wallet: Wallet,
    programId: PublicKey = PROGRAM_ID,
    config: VaultSdkConfig = {}
  ) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId;
    this.config = {
      commitment: config.commitment ?? "confirmed",
      skipPreflight: config.skipPreflight ?? false,
    };
  }

  /**
   * Initialize the SDK with the program IDL
   * Must be called before using other methods
   */
  async initialize(idl: Idl): Promise<void> {
    const provider = new AnchorProvider(this.connection, this.wallet, {
      commitment: this.config.commitment,
      skipPreflight: this.config.skipPreflight,
    });

    this.program = new Program(idl as SublyVault, provider) as Program<SublyVault>;
  }

  /**
   * Get the Shield Pool PDA address
   */
  getShieldPoolAddress(): PublicKey {
    const [pda] = getShieldPoolPda(this.programId);
    return pda;
  }

  /**
   * Fetch the Shield Pool account data
   */
  async getShieldPool(): Promise<ShieldPool | null> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");

    try {
      const poolAddress = this.getShieldPoolAddress();
      const pool = await (this.program.account as any).shieldPool.fetch(poolAddress);
      return pool as ShieldPool;
    } catch {
      return null;
    }
  }

  /**
   * Initialize a user's secret and commitment
   * This should be called once when a user first interacts with the vault
   */
  initializeUser(existingSecret?: Uint8Array): { secret: Uint8Array; commitment: Uint8Array } {
    const poolAddress = this.getShieldPoolAddress();
    this.userSecret = existingSecret ?? generateSecret();
    this.userCommitment = generateCommitment(this.userSecret, poolAddress);

    return {
      secret: this.userSecret,
      commitment: this.userCommitment,
    };
  }

  /**
   * Get or generate the user's commitment
   */
  getUserCommitment(): Uint8Array {
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }
    return this.userCommitment;
  }

  /**
   * Deposit USDC into the Shield Pool
   *
   * @param params - Deposit parameters
   * @returns Transaction result
   */
  async deposit(params: DepositParams): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;

    // Calculate shares
    const shares = this.calculateSharesForDeposit(
      amount,
      pool.totalPoolValue,
      pool.totalShares
    );

    // Create encrypted share (placeholder for now)
    const encryptedShare = createPlaceholderEncryptedShare(shares);

    // Get deposit index (based on pool nonce)
    const depositIndex = pool.nonce;

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [depositHistoryPda] = getDepositHistoryPda(
      this.userCommitment,
      BigInt(depositIndex.toString()),
      this.programId
    );

    try {
      const signature = await this.program.methods
        .deposit(amount, Array.from(this.userCommitment), Array.from(encryptedShare), depositIndex)
        .accounts({
          depositor: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          depositHistory: depositHistoryPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Deposit failed:", error);
      throw error;
    }
  }

  /**
   * Withdraw USDC from the Shield Pool
   *
   * @param params - Withdrawal parameters
   * @returns Transaction result
   */
  async withdraw(params: WithdrawParams): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;

    // Generate nullifier for this withdrawal
    const nullifier = generateNullifier(this.userSecret, "withdraw", BigInt(pool.nonce.toString()));

    // Calculate new shares after withdrawal
    const currentShares = await this.getUserShares();
    const sharesToBurn = this.calculateSharesForWithdrawal(
      amount,
      pool.totalPoolValue,
      pool.totalShares
    );
    const newShares = currentShares - sharesToBurn;

    // Create new encrypted share
    const newEncryptedShare = createPlaceholderEncryptedShare(newShares);

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [nullifierPda] = getNullifierPda(nullifier, this.programId);

    // Placeholder proof (ZK proof would be generated here in production)
    const proof: number[] = [];
    const publicInputs: number[][] = [];

    try {
      const signature = await this.program.methods
        .withdraw(
          amount,
          Array.from(nullifier),
          Array.from(newEncryptedShare),
          Buffer.from(proof),
          publicInputs.map((input) => Array.from(input))
        )
        .accounts({
          withdrawer: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          nullifier: nullifierPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Withdraw failed:", error);
      throw error;
    }
  }

  /**
   * Get the user's current balance
   *
   * @returns Balance in shares and USDC value
   */
  async getBalance(): Promise<BalanceResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      return { shares: 0n, valueUsdc: 0n };
    }

    const shares = await this.getUserShares();
    const valueUsdc = this.calculateShareValue(
      shares,
      pool.totalPoolValue,
      pool.totalShares
    );

    return { shares, valueUsdc };
  }

  /**
   * Set up a recurring payment
   *
   * @param params - Recurring payment parameters
   * @returns Transaction result
   */
  async setupRecurringPayment(params: SetupRecurringPaymentParams): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const intervalSeconds = INTERVAL_SECONDS[params.interval];
    const amount = new BN(params.amountUsdc * 10 ** USDC_DECIMALS);

    // Use pool nonce as transfer nonce
    const transferNonce = new BN(pool.nonce.toString());

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [scheduledTransferPda] = getScheduledTransferPda(
      this.userCommitment,
      BigInt(transferNonce.toString()),
      this.programId
    );

    try {
      const signature = await this.program.methods
        .setupTransfer(params.recipientAddress, amount, intervalSeconds, transferNonce)
        .accounts({
          payer: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          scheduledTransfer: scheduledTransferPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Setup recurring payment failed:", error);
      throw error;
    }
  }

  /**
   * Cancel a recurring payment
   *
   * @param transferId - The scheduled transfer PDA address
   * @returns Transaction result
   */
  async cancelRecurringPayment(transferId: PublicKey): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);

    try {
      const signature = await this.program.methods
        .cancelTransfer()
        .accounts({
          authority: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          scheduledTransfer: transferId,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Cancel recurring payment failed:", error);
      throw error;
    }
  }

  /**
   * Get yield information for the pool
   *
   * @returns Current APY and earned yield
   */
  async getYieldInfo(): Promise<YieldInfo> {
    const pool = await this.getShieldPool();
    if (!pool) {
      return { apy: 0, earnedUsdc: 0n };
    }

    // TODO: Integrate with Kamino to get actual APY
    // For now, return placeholder values
    const apy = 5.0; // 5% placeholder APY

    // Calculate user's earned yield based on their share
    const balance = await this.getBalance();
    // Simplified: yield = balance * (apy / 100) * time_fraction
    // For demo, we'll show 0 earned
    const earnedUsdc = 0n;

    return { apy, earnedUsdc };
  }

  // ============================================
  // Private helper methods
  // ============================================

  /**
   * Get user's share account
   */
  private async getUserShareAccount(): Promise<UserShare | null> {
    if (!this.program || !this.userCommitment) return null;

    try {
      const poolAddress = this.getShieldPoolAddress();
      const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
      const userShare = await (this.program.account as any).userShare.fetch(userSharePda);
      return userShare as UserShare;
    } catch {
      return null;
    }
  }

  /**
   * Get user's current shares (decrypted)
   */
  private async getUserShares(): Promise<bigint> {
    const userShare = await this.getUserShareAccount();
    if (!userShare) return 0n;

    // Read from placeholder encrypted share
    return readPlaceholderShares(new Uint8Array(userShare.encryptedShareAmount));
  }

  /**
   * Calculate shares to mint for a deposit
   */
  private calculateSharesForDeposit(
    depositAmount: BN,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalPoolValue.isZero() || totalShares.isZero()) {
      return BigInt(depositAmount.toString());
    }

    // shares = deposit * total_shares / total_pool_value
    const shares = depositAmount.mul(totalShares).div(totalPoolValue);
    return BigInt(shares.toString());
  }

  /**
   * Calculate shares to burn for a withdrawal
   */
  private calculateSharesForWithdrawal(
    withdrawalAmount: BN,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalPoolValue.isZero()) return 0n;

    // shares = withdrawal * total_shares / total_pool_value
    const shares = withdrawalAmount.mul(totalShares).div(totalPoolValue);
    return BigInt(shares.toString());
  }

  /**
   * Calculate the value of shares in USDC
   */
  private calculateShareValue(
    shares: bigint,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalShares.isZero()) return 0n;

    // value = shares * total_pool_value / total_shares
    const value = new BN(shares.toString()).mul(totalPoolValue).div(totalShares);
    return BigInt(value.toString());
  }
}

/**
 * Create a new SublyVaultClient instance
 *
 * @param connection - Solana RPC connection
 * @param wallet - User's wallet
 * @param config - Optional SDK configuration
 * @returns A new SublyVaultClient instance
 */
export function createSublyVaultClient(
  connection: Connection,
  wallet: Wallet,
  config?: VaultSdkConfig
): SublyVaultClient {
  return new SublyVaultClient(connection, wallet, PROGRAM_ID, config);
}
