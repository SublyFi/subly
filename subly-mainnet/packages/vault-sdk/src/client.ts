import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  Signer,
} from "@solana/web3.js";
import { Program, AnchorProvider, BN, Idl, Wallet } from "@coral-xyz/anchor";
import {
  ShieldPool,
  UserShare,
  DepositParams,
  RegisterDepositParams,
  WithdrawParams,
  SetupRecurringPaymentParams,
  BalanceResult,
  YieldInfo,
  TransactionResult,
  VaultSdkConfig,
  PROGRAM_ID,
  INTERVAL_SECONDS,
  USDC_DECIMALS,
  KAMINO_LENDING_PROGRAM_ID,
  KAMINO_MAIN_MARKET,
  KAMINO_USDC_RESERVE,
  KAMINO_CUSDC_MINT,
} from "./types";
import {
  getShieldPoolPda,
  getUserSharePda,
  getDepositHistoryPda,
  getScheduledTransferPda,
  getNullifierPda,
  getNoteCommitmentRegistryPda,
  getPoolTokenAccountPda,
  getPoolCtokenAccountPda,
  getKaminoLendingMarketAuthorityPda,
} from "./utils/pda";
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { generateCommitment, generateSecret, generateNullifier } from "./utils/commitment";
import {
  createPlaceholderEncryptedShare,
  readPlaceholderShares,
  KEY_DERIVATION_MESSAGE,
} from "./utils/encryption";
import {
  LocalStorageManager,
  LocalTransferData,
  encryptTransferData,
  decryptTransferData,
} from "./utils/local-storage";

// External protocol integrations
import {
  PrivacyCashIntegration,
  PrivacyCashConfig,
  createPrivacyCashIntegration,
  USDC_MINT as PRIVACY_CASH_USDC_MINT,
} from "./integrations/privacy-cash";
import {
  TukTukIntegration,
  TukTukConfig,
  createTukTukIntegration,
  PendingTransfer,
} from "./integrations/tuktuk";
import {
  KaminoIntegration,
  KaminoConfig,
  createKaminoIntegration,
  KaminoYieldInfo,
} from "./integrations/kamino";

// Import IDL type (will be generated by anchor build)
import type { SublyVault } from "./idl/subly_vault";

/**
 * SublyVaultClient - Main SDK client for interacting with the Subly Vault program
 *
 * Provides methods for:
 * - Depositing USDC into the privacy pool
 * - Withdrawing USDC privately
 * - Setting up and managing recurring payments
 * - Checking balances and yield information
 */
export class SublyVaultClient {
  private connection: Connection;
  private wallet: Wallet;
  private program: Program<SublyVault> | null = null;
  private programId: PublicKey;
  private config: VaultSdkConfig;

  // External protocol integrations (Privacy Cash is REQUIRED)
  private privacyCash: PrivacyCashIntegration | null = null;
  private tuktuk: TukTukIntegration | null = null;
  private kamino: KaminoIntegration | null = null;

  // Local storage for privacy-sensitive data (recipient addresses)
  private localStorage: LocalStorageManager;

  // Cached data
  private userSecret: Uint8Array | null = null;
  private userCommitment: Uint8Array | null = null;

  constructor(
    connection: Connection,
    wallet: Wallet,
    programId: PublicKey = PROGRAM_ID,
    config: VaultSdkConfig = {}
  ) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId;
    this.config = {
      commitment: config.commitment ?? "confirmed",
      skipPreflight: config.skipPreflight ?? false,
      storageKey: config.storageKey ?? "subly-vault",
    };

    // Initialize local storage for privacy-sensitive data
    this.localStorage = new LocalStorageManager(this.config.storageKey!);
  }

  /**
   * Initialize the SDK with the program IDL
   * Must be called before using other methods
   *
   * IMPORTANT: Privacy Cash is REQUIRED for privacy-preserving operations.
   * All deposits and transfers must go through Privacy Cash to protect user privacy.
   *
   * @param idl - Program IDL
   * @param options - Initialization options for external integrations
   */
  async initialize(
    idl: Idl,
    options: {
      /** REQUIRED: Private key for Privacy Cash operations */
      privacyCashPrivateKey: string | Uint8Array | Keypair;
      rpcUrl?: string;
      enableTukTuk?: boolean;
      enableKamino?: boolean;
      /** Encryption password for local storage (default: derived from wallet) */
      storagePassword?: string;
    }
  ): Promise<void> {
    const provider = new AnchorProvider(this.connection, this.wallet, {
      commitment: this.config.commitment,
      skipPreflight: this.config.skipPreflight,
    });

    this.program = new Program(idl as SublyVault, provider) as Program<SublyVault>;

    // Initialize local storage with encryption
    const storagePassword = options.storagePassword ?? this.wallet.publicKey.toBase58();
    await this.localStorage.initialize(storagePassword);

    // Initialize Privacy Cash (REQUIRED for privacy)
    const rpcUrl = options.rpcUrl ?? this.connection.rpcEndpoint;
    this.privacyCash = await createPrivacyCashIntegration({
      rpcUrl,
      privateKey: options.privacyCashPrivateKey,
      enableDebug: false,
    });

    if (options.enableTukTuk) {
      const poolAuthority = this.getShieldPoolAddress();
      // Note: Tuk Tuk requires a Keypair for signing, would need to be provided
      // For now, we'll create a placeholder that can be updated
      this.tuktuk = createTukTukIntegration({
        connection: this.connection,
        payer: Keypair.generate(), // Placeholder - should be provided
        authority: poolAuthority,
      });
    }

    if (options.enableKamino) {
      const poolAuthority = this.getShieldPoolAddress();
      this.kamino = await createKaminoIntegration({
        connection: this.connection,
        payer: Keypair.generate(), // Placeholder - should be provided
        poolAuthority,
      });
    }
  }

  /**
   * Get the Shield Pool PDA address
   */
  getShieldPoolAddress(): PublicKey {
    const [pda] = getShieldPoolPda(this.programId);
    return pda;
  }

  /**
   * Fetch the Shield Pool account data
   */
  async getShieldPool(): Promise<ShieldPool | null> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");

    try {
      const poolAddress = this.getShieldPoolAddress();
      const pool = await (this.program.account as any).shieldPool.fetch(poolAddress);
      return pool as ShieldPool;
    } catch {
      return null;
    }
  }

  /**
   * Initialize a user's secret and commitment
   * This should be called once when a user first interacts with the vault
   */
  initializeUser(existingSecret?: Uint8Array): { secret: Uint8Array; commitment: Uint8Array } {
    const poolAddress = this.getShieldPoolAddress();
    this.userSecret = existingSecret ?? generateSecret();
    this.userCommitment = generateCommitment(this.userSecret, poolAddress);

    return {
      secret: this.userSecret,
      commitment: this.userCommitment,
    };
  }

  /**
   * Get or generate the user's commitment
   */
  getUserCommitment(): Uint8Array {
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }
    return this.userCommitment;
  }

  /**
   * Register a private deposit from Privacy Cash
   *
   * This is the PREFERRED method for deposits as it preserves privacy.
   * The deposit flow is:
   * 1. User deposits USDC to Privacy Cash (separate transaction)
   * 2. Privacy Cash returns a note_commitment as proof
   * 3. User calls registerDeposit with the note_commitment
   * 4. The registrar (relayer or user) registers without exposing the user's wallet
   *
   * After registration, USDC is deposited to Kamino for yield generation.
   *
   * @param params - Register deposit parameters
   * @returns Transaction result
   */
  async registerDeposit(params: RegisterDepositParams): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }
    if (!this.privacyCash) {
      throw new Error("Privacy Cash is required for privacy-preserving deposits.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;

    // Calculate shares
    const shares = this.calculateSharesForDeposit(
      amount,
      pool.totalPoolValue,
      pool.totalShares
    );

    // Create encrypted share (placeholder for now)
    const encryptedShare = createPlaceholderEncryptedShare(shares);

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [noteCommitmentRegistryPda] = getNoteCommitmentRegistryPda(
      params.noteCommitment,
      this.programId
    );

    // Pool token accounts
    const [poolTokenAccountPda] = getPoolTokenAccountPda(poolAddress, this.programId);
    const [poolCtokenAccountPda] = getPoolCtokenAccountPda(poolAddress, this.programId);

    // Kamino accounts
    const [kaminoLendingMarketAuthority] = getKaminoLendingMarketAuthorityPda(
      KAMINO_MAIN_MARKET,
      KAMINO_LENDING_PROGRAM_ID
    );

    // Kamino reserve liquidity supply - needs to be fetched from reserve data
    // For now, use a placeholder that will be set correctly by the on-chain program
    const kaminoReserveLiquiditySupply = await this.getKaminoReserveLiquiditySupply();

    try {
      const signature = await this.program.methods
        .registerDeposit(
          Array.from(params.noteCommitment),
          Array.from(this.userCommitment),
          Array.from(encryptedShare),
          amount
        )
        .accounts({
          registrar: this.wallet.publicKey,
          shieldPool: poolAddress,
          noteCommitmentRegistry: noteCommitmentRegistryPda,
          userShare: userSharePda,
          poolTokenAccount: poolTokenAccountPda,
          poolCtokenAccount: poolCtokenAccountPda,
          kaminoLendingMarket: KAMINO_MAIN_MARKET,
          kaminoLendingMarketAuthority: kaminoLendingMarketAuthority,
          kaminoReserve: KAMINO_USDC_RESERVE,
          kaminoReserveLiquiditySupply: kaminoReserveLiquiditySupply,
          kaminoReserveCollateralMint: KAMINO_CUSDC_MINT,
          kaminoProgram: KAMINO_LENDING_PROGRAM_ID,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Register deposit failed:", error);
      throw error;
    }
  }

  /**
   * Deposit USDC into the Shield Pool via Privacy Cash
   *
   * This method performs a complete privacy-preserving deposit:
   * 1. Deposits USDC to Privacy Cash
   * 2. Gets the note_commitment from Privacy Cash
   * 3. Registers the deposit on-chain
   *
   * @deprecated For more control, use depositToPrivacyCash() + registerDeposit() separately
   * @param params - Deposit parameters
   * @returns Transaction result with Privacy Cash info
   */
  async deposit(params: DepositParams): Promise<TransactionResult & { noteCommitment?: Uint8Array }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }
    if (!this.privacyCash) {
      throw new Error("Privacy Cash is required. Initialize with privacyCashPrivateKey.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;
    const amountUsdc = Number(amount.toString()) / 1e6; // Convert to human-readable USDC

    // Step 1: Deposit to Privacy Cash (REQUIRED for privacy)
    let noteCommitment: Uint8Array;
    try {
      const privacyResult = await this.privacyCash.depositPrivateUSDC(amountUsdc);
      console.log("Privacy Cash deposit completed:", privacyResult.tx);
      // Note: In production, noteCommitment would be extracted from Privacy Cash response
      // For now, use a placeholder based on the transaction signature
      noteCommitment = new Uint8Array(32);
      const txBytes = Buffer.from(privacyResult.tx, "base64");
      noteCommitment.set(txBytes.slice(0, 32));
    } catch (error) {
      console.error("Privacy Cash deposit failed:", error);
      throw new Error(`Privacy Cash deposit failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }

    // Step 2: Register the deposit on-chain
    const registerResult = await this.registerDeposit({
      noteCommitment,
      amount,
    });

    return {
      ...registerResult,
      noteCommitment,
    };
  }

  /**
   * Withdraw USDC from the Shield Pool via Privacy Cash
   *
   * All withdrawals go through Privacy Cash to preserve privacy.
   * USDC is first redeemed from Kamino, then transferred via Privacy Cash.
   *
   * @param params - Withdrawal parameters
   * @param recipient - Optional recipient address (defaults to self via Privacy Cash)
   * @returns Transaction result with Privacy Cash info
   */
  async withdraw(
    params: WithdrawParams,
    recipient?: string
  ): Promise<TransactionResult & { privacyCashTx: string; privacyCashFee: number }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }
    if (!this.privacyCash) {
      throw new Error("Privacy Cash is required. Initialize with privacyCashPrivateKey.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;
    const amountUsdc = Number(amount.toString()) / 1e6;

    // Generate nullifier for this withdrawal
    const nullifier = generateNullifier(this.userSecret, "withdraw", BigInt(pool.nonce.toString()));

    // Calculate new shares after withdrawal
    const currentShares = await this.getUserShares();
    const sharesToBurn = this.calculateSharesForWithdrawal(
      amount,
      pool.totalPoolValue,
      pool.totalShares
    );
    const newShares = currentShares - sharesToBurn;

    // Create new encrypted share
    const newEncryptedShare = createPlaceholderEncryptedShare(newShares);

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [nullifierPda] = getNullifierPda(nullifier, this.programId);

    // Pool token accounts
    const [poolTokenAccountPda] = getPoolTokenAccountPda(poolAddress, this.programId);
    const [poolCtokenAccountPda] = getPoolCtokenAccountPda(poolAddress, this.programId);

    // Kamino accounts
    const [kaminoLendingMarketAuthority] = getKaminoLendingMarketAuthorityPda(
      KAMINO_MAIN_MARKET,
      KAMINO_LENDING_PROGRAM_ID
    );
    const kaminoReserveLiquiditySupply = await this.getKaminoReserveLiquiditySupply();

    // Placeholder proof (ZK proof would be generated here in production)
    const proof: number[] = [];
    const publicInputs: number[][] = [];

    try {
      const signature = await this.program.methods
        .withdraw(
          amount,
          Array.from(nullifier),
          Array.from(newEncryptedShare),
          Buffer.from(proof),
          publicInputs.map((input) => Array.from(input))
        )
        .accounts({
          withdrawer: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          nullifier: nullifierPda,
          poolTokenAccount: poolTokenAccountPda,
          poolCtokenAccount: poolCtokenAccountPda,
          kaminoLendingMarket: KAMINO_MAIN_MARKET,
          kaminoLendingMarketAuthority: kaminoLendingMarketAuthority,
          kaminoReserve: KAMINO_USDC_RESERVE,
          kaminoReserveLiquiditySupply: kaminoReserveLiquiditySupply,
          kaminoReserveCollateralMint: KAMINO_CUSDC_MINT,
          kaminoProgram: KAMINO_LENDING_PROGRAM_ID,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      // Withdraw through Privacy Cash (REQUIRED for privacy)
      const privacyResult = await this.privacyCash.withdrawPrivateUSDC(amountUsdc, recipient);
      console.log("Privacy Cash withdrawal completed:", privacyResult.tx);

      return {
        signature,
        success: true,
        privacyCashTx: privacyResult.tx,
        privacyCashFee: privacyResult.feeBaseUnits / 1e6,
      };
    } catch (error) {
      console.error("Withdraw failed:", error);
      throw error;
    }
  }

  /**
   * Get the user's current balance
   *
   * @returns Balance in shares and USDC value
   */
  async getBalance(): Promise<BalanceResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      return { shares: 0n, valueUsdc: 0n };
    }

    const shares = await this.getUserShares();
    const valueUsdc = this.calculateShareValue(
      shares,
      pool.totalPoolValue,
      pool.totalShares
    );

    return { shares, valueUsdc };
  }

  /**
   * Set up a privacy-preserving recurring payment
   *
   * The recipient address is encrypted and stored locally - NOT on-chain.
   * On-chain only stores encrypted_transfer_data that cannot reveal the recipient.
   * At execution time, the recipient is loaded from local storage and sent via Privacy Cash.
   *
   * @param params - Recurring payment parameters
   * @param options - Optional configuration
   * @returns Transaction result with transfer ID and optional Tuk Tuk cron job info
   */
  async setupRecurringPayment(
    params: SetupRecurringPaymentParams,
    options?: {
      /** Create a Tuk Tuk cron job for automated execution */
      enableTukTukAutomation?: boolean;
      /** Amount of SOL to fund the cron job (default: 0.1 SOL) */
      cronJobFundingSol?: number;
    }
  ): Promise<TransactionResult & { transferId: string; cronJobPda?: string; cronJobTx?: string }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const intervalSeconds = INTERVAL_SECONDS[params.interval];
    const amount = new BN(params.amountUsdc * 10 ** USDC_DECIMALS);

    // Use pool nonce as transfer nonce
    const transferNonce = new BN(pool.nonce.toString());

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [scheduledTransferPda] = getScheduledTransferPda(
      this.userCommitment,
      BigInt(transferNonce.toString()),
      this.programId
    );

    // Derive encryption key from user secret (first 32 bytes)
    const encryptionKey = this.userSecret!.slice(0, 32);

    // Encrypt recipient for on-chain storage (privacy protection)
    const encryptedTransferData = await encryptTransferData(
      params.recipientAddress.toBase58(),
      encryptionKey,
      params.memo
    );

    try {
      const signature = await this.program.methods
        .setupTransfer(
          Array.from(encryptedTransferData),
          amount,
          intervalSeconds,
          transferNonce
        )
        .accounts({
          payer: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          scheduledTransfer: scheduledTransferPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      // Save recipient to local storage (NOT on-chain)
      const transferId = scheduledTransferPda.toBase58();
      const localTransferData: LocalTransferData = {
        transferId,
        recipient: params.recipientAddress.toBase58(),
        amount: params.amountUsdc,
        intervalSeconds,
        createdAt: Date.now(),
        memo: params.memo,
      };
      await this.localStorage.saveTransfer(localTransferData);

      let result: TransactionResult & { transferId: string; cronJobPda?: string; cronJobTx?: string } = {
        signature,
        success: true,
        transferId,
      };

      // If Tuk Tuk automation is enabled, create a cron job
      if (options?.enableTukTukAutomation && this.tuktuk) {
        try {
          // Import interval to cron schedule helper
          const { intervalToCronSchedule } = await import("./integrations/tuktuk");
          const cronSchedule = intervalToCronSchedule(intervalSeconds);

          // Create a job name based on transfer ID
          const jobName = `subly_transfer_${scheduledTransferPda.toBase58().slice(0, 8)}`;

          // Build execute_transfer instruction for the cron job
          const executeTransferIx = await this.program.methods
            .executeTransfer(0) // execution_index will be updated on each execution
            .accounts({
              executor: this.wallet.publicKey,
              shieldPool: poolAddress,
              scheduledTransfer: scheduledTransferPda,
              systemProgram: SystemProgram.programId,
            })
            .instruction();

          // Create the cron job
          const cronResult = await this.tuktuk.createCronJob(cronSchedule, executeTransferIx, jobName);
          result.cronJobPda = cronResult.cronJobPda.toBase58();
          result.cronJobTx = cronResult.tx;

          // Fund the cron job
          const fundingAmount = options.cronJobFundingSol ?? 0.1;
          await this.tuktuk.fundCronJob(cronResult.cronJobPda, fundingAmount);

          console.log("Tuk Tuk cron job created:", cronResult.cronJobPda.toBase58());
        } catch (error) {
          console.warn("Failed to create Tuk Tuk cron job:", error);
          // Note: The scheduled transfer was created successfully, but automation failed
          // Manual execution will be required
        }
      }

      return result;
    } catch (error) {
      console.error("Setup recurring payment failed:", error);
      throw error;
    }
  }

  /**
   * Get the recipient address for a scheduled transfer from local storage
   *
   * @param transferId - The scheduled transfer PDA address
   * @returns Recipient address or null if not found
   */
  async getTransferRecipient(transferId: string): Promise<string | null> {
    const transfer = await this.localStorage.getTransfer(transferId);
    return transfer?.recipient ?? null;
  }

  /**
   * Get all scheduled transfers from local storage
   *
   * @returns List of transfer data stored locally
   */
  async getAllLocalTransfers(): Promise<LocalTransferData[]> {
    return this.localStorage.getAllTransfers();
  }

  /**
   * Execute a scheduled transfer via Privacy Cash
   *
   * This method loads the recipient from local storage and sends via Privacy Cash.
   * On-chain, no recipient information is stored.
   *
   * @param transferId - The scheduled transfer PDA address
   * @param executionIndex - The execution index for tracking
   * @returns Transaction result with Privacy Cash info
   */
  async executeScheduledTransfer(
    transferId: PublicKey,
    executionIndex: number
  ): Promise<TransactionResult & { privacyCashTx: string }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.privacyCash) {
      throw new Error("Privacy Cash is required. Initialize with privacyCashPrivateKey.");
    }

    // Load recipient from local storage
    const localTransfer = await this.localStorage.getTransfer(transferId.toBase58());
    if (!localTransfer) {
      throw new Error(`Transfer not found in local storage: ${transferId.toBase58()}. Cannot execute without recipient.`);
    }

    // TODO: In production, this would involve batch proofs and the full execute_transfer flow
    // For now, this demonstrates the privacy-preserving pattern:
    // 1. Load recipient from local storage (not from chain)
    // 2. Execute transfer via Privacy Cash
    const privacyResult = await this.privacyCash.withdrawPrivateUSDC(
      localTransfer.amount,
      localTransfer.recipient
    );

    // Update local storage with execution info
    localTransfer.lastExecuted = Date.now();
    await this.localStorage.saveTransfer(localTransfer);

    return {
      signature: privacyResult.tx, // Use Privacy Cash tx as signature
      success: true,
      privacyCashTx: privacyResult.tx,
    };
  }

  /**
   * Cancel a recurring payment
   *
   * @param transferId - The scheduled transfer PDA address
   * @param options - Optional configuration
   * @returns Transaction result with optional Tuk Tuk cleanup info
   */
  async cancelRecurringPayment(
    transferId: PublicKey,
    options?: {
      /** Close associated Tuk Tuk cron job */
      closeCronJob?: boolean;
      /** The cron job PDA to close (required if closeCronJob is true) */
      cronJobPda?: PublicKey;
    }
  ): Promise<TransactionResult & { cronJobClosed?: boolean; refundedSol?: number }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);

    try {
      const signature = await this.program.methods
        .cancelTransfer()
        .accounts({
          authority: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          scheduledTransfer: transferId,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      let result: TransactionResult & { cronJobClosed?: boolean; refundedSol?: number } = {
        signature,
        success: true,
      };

      // If Tuk Tuk cron job cleanup is requested
      if (options?.closeCronJob && options.cronJobPda && this.tuktuk) {
        try {
          await this.tuktuk.closeCronJob(options.cronJobPda);
          result.cronJobClosed = true;
          console.log("Tuk Tuk cron job closed:", options.cronJobPda.toBase58());
        } catch (error) {
          console.warn("Failed to close Tuk Tuk cron job:", error);
          result.cronJobClosed = false;
          // Note: The scheduled transfer was cancelled, but cron job cleanup failed
          // This may leave an orphaned cron job that can be cleaned up later
        }
      }

      return result;
    } catch (error) {
      console.error("Cancel recurring payment failed:", error);
      throw error;
    }
  }

  /**
   * Get yield information for the pool
   *
   * @returns Current APY and earned yield
   */
  async getYieldInfo(): Promise<YieldInfo> {
    const pool = await this.getShieldPool();
    if (!pool) {
      return { apy: 0, earnedUsdc: 0n };
    }

    // Try to get real APY from Kamino if integrated
    if (this.kamino) {
      try {
        const kaminoYield = await this.kamino.getKaminoYieldInfo();
        return {
          apy: kaminoYield.apy * 100, // Convert decimal to percentage
          earnedUsdc: BigInt(Math.floor(kaminoYield.earnedYield * 1e6)), // Convert to base units
        };
      } catch (error) {
        console.warn("Failed to get Kamino yield info:", error);
      }
    }

    // Fallback to placeholder values
    const apy = 5.0; // 5% placeholder APY
    const earnedUsdc = 0n;

    return { apy, earnedUsdc };
  }

  // ============================================
  // Privacy Cash Integration Methods
  // ============================================

  /**
   * Deposit USDC privately using Privacy Cash
   *
   * @param amount Amount in USDC (human-readable)
   * @returns Transaction signature
   */
  async depositPrivate(amount: number): Promise<{ tx: string }> {
    if (!this.privacyCash) {
      throw new Error("Privacy Cash not initialized. Enable it during initialize()");
    }

    return this.privacyCash.depositPrivateUSDC(amount);
  }

  /**
   * Withdraw USDC privately using Privacy Cash
   *
   * @param amount Amount in USDC (human-readable)
   * @param recipient Optional recipient address
   * @returns Withdrawal result
   */
  async withdrawPrivate(amount: number, recipient?: string): Promise<{
    tx: string;
    amountReceived: number;
    fee: number;
  }> {
    if (!this.privacyCash) {
      throw new Error("Privacy Cash not initialized. Enable it during initialize()");
    }

    const result = await this.privacyCash.withdrawPrivateUSDC(amount, recipient);
    return {
      tx: result.tx,
      amountReceived: result.baseUnits / 1e6,
      fee: result.feeBaseUnits / 1e6,
    };
  }

  /**
   * Get private USDC balance from Privacy Cash
   *
   * @returns Balance in USDC
   */
  async getPrivateBalance(): Promise<number> {
    if (!this.privacyCash) {
      throw new Error("Privacy Cash not initialized. Enable it during initialize()");
    }

    return this.privacyCash.getPrivateUSDCBalance();
  }

  // ============================================
  // Tuk Tuk Automation Methods
  // ============================================

  /**
   * Check for pending transfers that are due for execution
   *
   * @param scheduledTransferPdas List of scheduled transfer PDAs to check
   * @returns List of pending transfers
   */
  async checkPendingTransfers(scheduledTransferPdas: PublicKey[]): Promise<PendingTransfer[]> {
    if (!this.tuktuk) {
      throw new Error("Tuk Tuk not initialized. Enable it during initialize()");
    }

    return this.tuktuk.checkPendingTransfers(scheduledTransferPdas);
  }

  /**
   * Manually execute a pending transfer
   * Use this when Tuk Tuk automation is not active
   *
   * @param transferId Transfer ID (PDA address as string)
   * @param executeTransferIx The execute_transfer instruction
   * @returns Transaction signature
   */
  async executePendingTransfer(
    transferId: string,
    executeTransferIx: TransactionInstruction
  ): Promise<{ tx: string }> {
    if (!this.tuktuk) {
      throw new Error("Tuk Tuk not initialized. Enable it during initialize()");
    }

    return this.tuktuk.executePendingTransfer(transferId, executeTransferIx);
  }

  // ============================================
  // Kamino Yield Methods
  // ============================================

  /**
   * Deposit to Kamino Lending for yield generation
   *
   * @param amount Amount in USDC
   * @returns Deposit result
   */
  async depositToKamino(amount: number): Promise<{ tx: string }> {
    if (!this.kamino) {
      throw new Error("Kamino not initialized. Enable it during initialize()");
    }

    const result = await this.kamino.depositToKamino(amount);
    return { tx: result.tx };
  }

  /**
   * Withdraw from Kamino Lending
   *
   * @param amount Amount in USDC
   * @returns Withdrawal result
   */
  async withdrawFromKamino(amount: number): Promise<{ tx: string }> {
    if (!this.kamino) {
      throw new Error("Kamino not initialized. Enable it during initialize()");
    }

    const result = await this.kamino.withdrawFromKamino(amount);
    return { tx: result.tx };
  }

  /**
   * Get detailed yield information from Kamino
   *
   * @returns Kamino yield info
   */
  async getKaminoYieldInfo(): Promise<KaminoYieldInfo> {
    if (!this.kamino) {
      throw new Error("Kamino not initialized. Enable it during initialize()");
    }

    return this.kamino.getKaminoYieldInfo();
  }

  // ============================================
  // Pool Value Management
  // ============================================

  /**
   * Update the pool's total value based on Kamino yield
   *
   * This reads the current cToken balance and calculates the equivalent
   * USDC value. Should be called periodically (e.g., daily) by the pool authority.
   *
   * @param exchangeRateNumerator - Current Kamino exchange rate numerator
   * @param exchangeRateDenominator - Current Kamino exchange rate denominator
   * @returns Transaction result
   */
  async updatePoolValue(
    exchangeRateNumerator: BN,
    exchangeRateDenominator: BN
  ): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");

    const poolAddress = this.getShieldPoolAddress();
    const [poolTokenAccountPda] = getPoolTokenAccountPda(poolAddress, this.programId);
    const [poolCtokenAccountPda] = getPoolCtokenAccountPda(poolAddress, this.programId);

    try {
      const signature = await this.program.methods
        .updatePoolValue(exchangeRateNumerator, exchangeRateDenominator)
        .accounts({
          authority: this.wallet.publicKey,
          shieldPool: poolAddress,
          poolCtokenAccount: poolCtokenAccountPda,
          poolTokenAccount: poolTokenAccountPda,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Update pool value failed:", error);
      throw error;
    }
  }

  /**
   * Get the actual pool value including Kamino yield
   *
   * Calculates the current value by reading cToken balance and applying
   * the current exchange rate.
   *
   * @returns Pool value in USDC (base units)
   */
  async getActualPoolValue(): Promise<bigint> {
    if (!this.kamino) {
      // Fallback to stored pool value if Kamino integration not available
      const pool = await this.getShieldPool();
      return pool ? BigInt(pool.totalPoolValue.toString()) : 0n;
    }

    try {
      const yieldInfo = await this.kamino.getKaminoYieldInfo();
      return BigInt(Math.floor(yieldInfo.currentValue * 1e6));
    } catch (error) {
      console.warn("Failed to get actual pool value from Kamino:", error);
      const pool = await this.getShieldPool();
      return pool ? BigInt(pool.totalPoolValue.toString()) : 0n;
    }
  }

  // ============================================
  // Private helper methods
  // ============================================

  /**
   * Get Kamino reserve liquidity supply address
   * This is the token account where USDC liquidity is stored in the reserve
   */
  private async getKaminoReserveLiquiditySupply(): Promise<PublicKey> {
    // The liquidity supply account is derived from the reserve
    // For Kamino, this is typically an ATA of the reserve
    // In production, this should be fetched from the reserve account data
    // For now, we use a known address or derive it
    try {
      if (this.kamino) {
        // If Kamino integration is available, get from there
        const klendSdk = await import("@kamino-finance/klend-sdk");
        // This would need proper implementation based on Kamino SDK
      }
    } catch {
      // Fallback
    }

    // Hardcoded address for Kamino USDC reserve liquidity supply on mainnet
    // This should be fetched dynamically in production
    return new PublicKey("BDdS2G7cZPVxJNkHqTEMHk8WkFvhGNm3X1sNzTMPaLbk");
  }

  /**
   * Get user's share account
   */
  private async getUserShareAccount(): Promise<UserShare | null> {
    if (!this.program || !this.userCommitment) return null;

    try {
      const poolAddress = this.getShieldPoolAddress();
      const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
      const userShare = await (this.program.account as any).userShare.fetch(userSharePda);
      return userShare as UserShare;
    } catch {
      return null;
    }
  }

  /**
   * Get user's current shares (decrypted)
   */
  private async getUserShares(): Promise<bigint> {
    const userShare = await this.getUserShareAccount();
    if (!userShare) return 0n;

    // Read from placeholder encrypted share
    return readPlaceholderShares(new Uint8Array(userShare.encryptedShareAmount));
  }

  /**
   * Calculate shares to mint for a deposit
   */
  private calculateSharesForDeposit(
    depositAmount: BN,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalPoolValue.isZero() || totalShares.isZero()) {
      return BigInt(depositAmount.toString());
    }

    // shares = deposit * total_shares / total_pool_value
    const shares = depositAmount.mul(totalShares).div(totalPoolValue);
    return BigInt(shares.toString());
  }

  /**
   * Calculate shares to burn for a withdrawal
   */
  private calculateSharesForWithdrawal(
    withdrawalAmount: BN,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalPoolValue.isZero()) return 0n;

    // shares = withdrawal * total_shares / total_pool_value
    const shares = withdrawalAmount.mul(totalShares).div(totalPoolValue);
    return BigInt(shares.toString());
  }

  /**
   * Calculate the value of shares in USDC
   */
  private calculateShareValue(
    shares: bigint,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalShares.isZero()) return 0n;

    // value = shares * total_pool_value / total_shares
    const value = new BN(shares.toString()).mul(totalPoolValue).div(totalShares);
    return BigInt(value.toString());
  }
}

/**
 * Create a new SublyVaultClient instance
 *
 * @param connection - Solana RPC connection
 * @param wallet - User's wallet
 * @param config - Optional SDK configuration
 * @returns A new SublyVaultClient instance
 */
export function createSublyVaultClient(
  connection: Connection,
  wallet: Wallet,
  config?: VaultSdkConfig
): SublyVaultClient {
  return new SublyVaultClient(connection, wallet, PROGRAM_ID, config);
}
