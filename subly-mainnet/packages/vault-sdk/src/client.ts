import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  Signer,
} from "@solana/web3.js";
import { Program, AnchorProvider, BN, Idl, Wallet } from "@coral-xyz/anchor";
import {
  ShieldPool,
  UserShare,
  DepositParams,
  WithdrawParams,
  SetupRecurringPaymentParams,
  BalanceResult,
  YieldInfo,
  TransactionResult,
  VaultSdkConfig,
  PROGRAM_ID,
  INTERVAL_SECONDS,
  USDC_DECIMALS,
} from "./types";
import {
  getShieldPoolPda,
  getUserSharePda,
  getDepositHistoryPda,
  getScheduledTransferPda,
  getNullifierPda,
} from "./utils/pda";
import { generateCommitment, generateSecret, generateNullifier } from "./utils/commitment";
import {
  createPlaceholderEncryptedShare,
  readPlaceholderShares,
  KEY_DERIVATION_MESSAGE,
} from "./utils/encryption";

// External protocol integrations
import {
  PrivacyCashIntegration,
  PrivacyCashConfig,
  createPrivacyCashIntegration,
  USDC_MINT as PRIVACY_CASH_USDC_MINT,
} from "./integrations/privacy-cash";
import {
  TukTukIntegration,
  TukTukConfig,
  createTukTukIntegration,
  PendingTransfer,
} from "./integrations/tuktuk";
import {
  KaminoIntegration,
  KaminoConfig,
  createKaminoIntegration,
  KaminoYieldInfo,
} from "./integrations/kamino";

// Import IDL type (will be generated by anchor build)
import type { SublyVault } from "./idl/subly_vault";

/**
 * SublyVaultClient - Main SDK client for interacting with the Subly Vault program
 *
 * Provides methods for:
 * - Depositing USDC into the privacy pool
 * - Withdrawing USDC privately
 * - Setting up and managing recurring payments
 * - Checking balances and yield information
 */
export class SublyVaultClient {
  private connection: Connection;
  private wallet: Wallet;
  private program: Program<SublyVault> | null = null;
  private programId: PublicKey;
  private config: VaultSdkConfig;

  // External protocol integrations
  private privacyCash: PrivacyCashIntegration | null = null;
  private tuktuk: TukTukIntegration | null = null;
  private kamino: KaminoIntegration | null = null;

  // Cached data
  private userSecret: Uint8Array | null = null;
  private userCommitment: Uint8Array | null = null;

  constructor(
    connection: Connection,
    wallet: Wallet,
    programId: PublicKey = PROGRAM_ID,
    config: VaultSdkConfig = {}
  ) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId;
    this.config = {
      commitment: config.commitment ?? "confirmed",
      skipPreflight: config.skipPreflight ?? false,
    };
  }

  /**
   * Initialize the SDK with the program IDL
   * Must be called before using other methods
   *
   * @param idl - Program IDL
   * @param options - Optional initialization options for external integrations
   */
  async initialize(
    idl: Idl,
    options?: {
      privacyCashPrivateKey?: string | Uint8Array | Keypair;
      rpcUrl?: string;
      enablePrivacyCash?: boolean;
      enableTukTuk?: boolean;
      enableKamino?: boolean;
    }
  ): Promise<void> {
    const provider = new AnchorProvider(this.connection, this.wallet, {
      commitment: this.config.commitment,
      skipPreflight: this.config.skipPreflight,
    });

    this.program = new Program(idl as SublyVault, provider) as Program<SublyVault>;

    // Initialize external integrations if requested
    const rpcUrl = options?.rpcUrl ?? this.connection.rpcEndpoint;

    if (options?.enablePrivacyCash && options.privacyCashPrivateKey) {
      this.privacyCash = await createPrivacyCashIntegration({
        rpcUrl,
        privateKey: options.privacyCashPrivateKey,
        enableDebug: false,
      });
    }

    if (options?.enableTukTuk) {
      const poolAuthority = this.getShieldPoolAddress();
      // Note: Tuk Tuk requires a Keypair for signing, would need to be provided
      // For now, we'll create a placeholder that can be updated
      this.tuktuk = createTukTukIntegration({
        connection: this.connection,
        payer: Keypair.generate(), // Placeholder - should be provided
        authority: poolAuthority,
      });
    }

    if (options?.enableKamino) {
      const poolAuthority = this.getShieldPoolAddress();
      this.kamino = await createKaminoIntegration({
        connection: this.connection,
        payer: Keypair.generate(), // Placeholder - should be provided
        poolAuthority,
      });
    }
  }

  /**
   * Get the Shield Pool PDA address
   */
  getShieldPoolAddress(): PublicKey {
    const [pda] = getShieldPoolPda(this.programId);
    return pda;
  }

  /**
   * Fetch the Shield Pool account data
   */
  async getShieldPool(): Promise<ShieldPool | null> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");

    try {
      const poolAddress = this.getShieldPoolAddress();
      const pool = await (this.program.account as any).shieldPool.fetch(poolAddress);
      return pool as ShieldPool;
    } catch {
      return null;
    }
  }

  /**
   * Initialize a user's secret and commitment
   * This should be called once when a user first interacts with the vault
   */
  initializeUser(existingSecret?: Uint8Array): { secret: Uint8Array; commitment: Uint8Array } {
    const poolAddress = this.getShieldPoolAddress();
    this.userSecret = existingSecret ?? generateSecret();
    this.userCommitment = generateCommitment(this.userSecret, poolAddress);

    return {
      secret: this.userSecret,
      commitment: this.userCommitment,
    };
  }

  /**
   * Get or generate the user's commitment
   */
  getUserCommitment(): Uint8Array {
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }
    return this.userCommitment;
  }

  /**
   * Deposit USDC into the Shield Pool
   *
   * @param params - Deposit parameters
   * @param options - Optional configuration
   * @returns Transaction result
   */
  async deposit(
    params: DepositParams,
    options?: {
      /** Use Privacy Cash for private deposit */
      usePrivacyCash?: boolean;
    }
  ): Promise<TransactionResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;
    const amountUsdc = Number(amount.toString()) / 1e6; // Convert to human-readable USDC

    // If Privacy Cash is enabled and requested, deposit through Privacy Cash first
    if (options?.usePrivacyCash && this.privacyCash) {
      try {
        const privacyResult = await this.privacyCash.depositPrivateUSDC(amountUsdc);
        console.log("Privacy Cash deposit completed:", privacyResult.tx);
      } catch (error) {
        console.error("Privacy Cash deposit failed:", error);
        throw new Error(`Privacy Cash deposit failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    // Calculate shares
    const shares = this.calculateSharesForDeposit(
      amount,
      pool.totalPoolValue,
      pool.totalShares
    );

    // Create encrypted share (placeholder for now)
    const encryptedShare = createPlaceholderEncryptedShare(shares);

    // Get deposit index (based on pool nonce)
    const depositIndex = pool.nonce;

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [depositHistoryPda] = getDepositHistoryPda(
      this.userCommitment,
      BigInt(depositIndex.toString()),
      this.programId
    );

    try {
      const signature = await this.program.methods
        .deposit(amount, Array.from(this.userCommitment), Array.from(encryptedShare), depositIndex)
        .accounts({
          depositor: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          depositHistory: depositHistoryPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, success: true };
    } catch (error) {
      console.error("Deposit failed:", error);
      throw error;
    }
  }

  /**
   * Withdraw USDC from the Shield Pool
   *
   * @param params - Withdrawal parameters
   * @param options - Optional configuration
   * @returns Transaction result with optional Privacy Cash info
   */
  async withdraw(
    params: WithdrawParams,
    options?: {
      /** Use Privacy Cash for private withdrawal */
      usePrivacyCash?: boolean;
      /** Recipient address (for Privacy Cash withdrawal) */
      recipient?: string;
    }
  ): Promise<TransactionResult & { privacyCashTx?: string; privacyCashFee?: number }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userSecret || !this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const amount = typeof params.amount === "number" ? new BN(params.amount) : params.amount;

    // Generate nullifier for this withdrawal
    const nullifier = generateNullifier(this.userSecret, "withdraw", BigInt(pool.nonce.toString()));

    // Calculate new shares after withdrawal
    const currentShares = await this.getUserShares();
    const sharesToBurn = this.calculateSharesForWithdrawal(
      amount,
      pool.totalPoolValue,
      pool.totalShares
    );
    const newShares = currentShares - sharesToBurn;

    // Create new encrypted share
    const newEncryptedShare = createPlaceholderEncryptedShare(newShares);

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [nullifierPda] = getNullifierPda(nullifier, this.programId);

    // Placeholder proof (ZK proof would be generated here in production)
    const proof: number[] = [];
    const publicInputs: number[][] = [];

    try {
      const signature = await this.program.methods
        .withdraw(
          amount,
          Array.from(nullifier),
          Array.from(newEncryptedShare),
          Buffer.from(proof),
          publicInputs.map((input) => Array.from(input))
        )
        .accounts({
          withdrawer: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          nullifier: nullifierPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      let result: TransactionResult & { privacyCashTx?: string; privacyCashFee?: number } = {
        signature,
        success: true,
      };

      // If Privacy Cash is enabled and requested, withdraw through Privacy Cash
      if (options?.usePrivacyCash && this.privacyCash) {
        const amountUsdc = Number(amount.toString()) / 1e6; // Convert to human-readable USDC
        try {
          const privacyResult = await this.privacyCash.withdrawPrivateUSDC(amountUsdc, options.recipient);
          result.privacyCashTx = privacyResult.tx;
          result.privacyCashFee = privacyResult.feeInBaseUnits / 1e6;
          console.log("Privacy Cash withdrawal completed:", privacyResult.tx);
        } catch (error) {
          console.error("Privacy Cash withdrawal failed:", error);
          // Note: The vault withdrawal succeeded, but Privacy Cash failed
          // The funds are in the user's wallet but not privately withdrawn
        }
      }

      return result;
    } catch (error) {
      console.error("Withdraw failed:", error);
      throw error;
    }
  }

  /**
   * Get the user's current balance
   *
   * @returns Balance in shares and USDC value
   */
  async getBalance(): Promise<BalanceResult> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      return { shares: 0n, valueUsdc: 0n };
    }

    const shares = await this.getUserShares();
    const valueUsdc = this.calculateShareValue(
      shares,
      pool.totalPoolValue,
      pool.totalShares
    );

    return { shares, valueUsdc };
  }

  /**
   * Set up a recurring payment
   *
   * @param params - Recurring payment parameters
   * @param options - Optional configuration
   * @returns Transaction result with optional Tuk Tuk cron job info
   */
  async setupRecurringPayment(
    params: SetupRecurringPaymentParams,
    options?: {
      /** Create a Tuk Tuk cron job for automated execution */
      enableTukTukAutomation?: boolean;
      /** Amount of SOL to fund the cron job (default: 0.1 SOL) */
      cronJobFundingSol?: number;
    }
  ): Promise<TransactionResult & { cronJobPda?: string; cronJobTx?: string }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const pool = await this.getShieldPool();
    if (!pool) {
      throw new Error("Shield Pool not initialized");
    }

    const intervalSeconds = INTERVAL_SECONDS[params.interval];
    const amount = new BN(params.amountUsdc * 10 ** USDC_DECIMALS);

    // Use pool nonce as transfer nonce
    const transferNonce = new BN(pool.nonce.toString());

    // Build accounts
    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
    const [scheduledTransferPda] = getScheduledTransferPda(
      this.userCommitment,
      BigInt(transferNonce.toString()),
      this.programId
    );

    try {
      const signature = await this.program.methods
        .setupTransfer(params.recipientAddress, amount, intervalSeconds, transferNonce)
        .accounts({
          payer: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          scheduledTransfer: scheduledTransferPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      let result: TransactionResult & { cronJobPda?: string; cronJobTx?: string } = {
        signature,
        success: true,
      };

      // If Tuk Tuk automation is enabled, create a cron job
      if (options?.enableTukTukAutomation && this.tuktuk) {
        try {
          // Import interval to cron schedule helper
          const { intervalToCronSchedule } = await import("./integrations/tuktuk");
          const cronSchedule = intervalToCronSchedule(intervalSeconds);

          // Create a job name based on transfer ID
          const jobName = `subly_transfer_${scheduledTransferPda.toBase58().slice(0, 8)}`;

          // Build execute_transfer instruction for the cron job
          const executeTransferIx = await this.program.methods
            .executeTransfer()
            .accounts({
              executor: this.wallet.publicKey,
              shieldPool: poolAddress,
              scheduledTransfer: scheduledTransferPda,
              systemProgram: SystemProgram.programId,
            })
            .instruction();

          // Create the cron job
          const cronResult = await this.tuktuk.createCronJob(cronSchedule, executeTransferIx, jobName);
          result.cronJobPda = cronResult.cronJobPda.toBase58();
          result.cronJobTx = cronResult.tx;

          // Fund the cron job
          const fundingAmount = options.cronJobFundingSol ?? 0.1;
          await this.tuktuk.fundCronJob(cronResult.cronJobPda, fundingAmount);

          console.log("Tuk Tuk cron job created:", cronResult.cronJobPda.toBase58());
        } catch (error) {
          console.warn("Failed to create Tuk Tuk cron job:", error);
          // Note: The scheduled transfer was created successfully, but automation failed
          // Manual execution will be required
        }
      }

      return result;
    } catch (error) {
      console.error("Setup recurring payment failed:", error);
      throw error;
    }
  }

  /**
   * Cancel a recurring payment
   *
   * @param transferId - The scheduled transfer PDA address
   * @param options - Optional configuration
   * @returns Transaction result with optional Tuk Tuk cleanup info
   */
  async cancelRecurringPayment(
    transferId: PublicKey,
    options?: {
      /** Close associated Tuk Tuk cron job */
      closeCronJob?: boolean;
      /** The cron job PDA to close (required if closeCronJob is true) */
      cronJobPda?: PublicKey;
    }
  ): Promise<TransactionResult & { cronJobClosed?: boolean; refundedSol?: number }> {
    if (!this.program) throw new Error("SDK not initialized. Call initialize() first.");
    if (!this.userCommitment) {
      throw new Error("User not initialized. Call initializeUser() first.");
    }

    const poolAddress = this.getShieldPoolAddress();
    const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);

    try {
      const signature = await this.program.methods
        .cancelTransfer()
        .accounts({
          authority: this.wallet.publicKey,
          shieldPool: poolAddress,
          userShare: userSharePda,
          scheduledTransfer: transferId,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      let result: TransactionResult & { cronJobClosed?: boolean; refundedSol?: number } = {
        signature,
        success: true,
      };

      // If Tuk Tuk cron job cleanup is requested
      if (options?.closeCronJob && options.cronJobPda && this.tuktuk) {
        try {
          await this.tuktuk.closeCronJob(options.cronJobPda);
          result.cronJobClosed = true;
          console.log("Tuk Tuk cron job closed:", options.cronJobPda.toBase58());
        } catch (error) {
          console.warn("Failed to close Tuk Tuk cron job:", error);
          result.cronJobClosed = false;
          // Note: The scheduled transfer was cancelled, but cron job cleanup failed
          // This may leave an orphaned cron job that can be cleaned up later
        }
      }

      return result;
    } catch (error) {
      console.error("Cancel recurring payment failed:", error);
      throw error;
    }
  }

  /**
   * Get yield information for the pool
   *
   * @returns Current APY and earned yield
   */
  async getYieldInfo(): Promise<YieldInfo> {
    const pool = await this.getShieldPool();
    if (!pool) {
      return { apy: 0, earnedUsdc: 0n };
    }

    // Try to get real APY from Kamino if integrated
    if (this.kamino) {
      try {
        const kaminoYield = await this.kamino.getKaminoYieldInfo();
        return {
          apy: kaminoYield.apy * 100, // Convert decimal to percentage
          earnedUsdc: BigInt(Math.floor(kaminoYield.earnedYield * 1e6)), // Convert to base units
        };
      } catch (error) {
        console.warn("Failed to get Kamino yield info:", error);
      }
    }

    // Fallback to placeholder values
    const apy = 5.0; // 5% placeholder APY
    const earnedUsdc = 0n;

    return { apy, earnedUsdc };
  }

  // ============================================
  // Privacy Cash Integration Methods
  // ============================================

  /**
   * Deposit USDC privately using Privacy Cash
   *
   * @param amount Amount in USDC (human-readable)
   * @returns Transaction signature
   */
  async depositPrivate(amount: number): Promise<{ tx: string }> {
    if (!this.privacyCash) {
      throw new Error("Privacy Cash not initialized. Enable it during initialize()");
    }

    return this.privacyCash.depositPrivateUSDC(amount);
  }

  /**
   * Withdraw USDC privately using Privacy Cash
   *
   * @param amount Amount in USDC (human-readable)
   * @param recipient Optional recipient address
   * @returns Withdrawal result
   */
  async withdrawPrivate(amount: number, recipient?: string): Promise<{
    tx: string;
    amountReceived: number;
    fee: number;
  }> {
    if (!this.privacyCash) {
      throw new Error("Privacy Cash not initialized. Enable it during initialize()");
    }

    const result = await this.privacyCash.withdrawPrivateUSDC(amount, recipient);
    return {
      tx: result.tx,
      amountReceived: result.amountInBaseUnits / 1e6,
      fee: result.feeInBaseUnits / 1e6,
    };
  }

  /**
   * Get private USDC balance from Privacy Cash
   *
   * @returns Balance in USDC
   */
  async getPrivateBalance(): Promise<number> {
    if (!this.privacyCash) {
      throw new Error("Privacy Cash not initialized. Enable it during initialize()");
    }

    return this.privacyCash.getPrivateUSDCBalance();
  }

  // ============================================
  // Tuk Tuk Automation Methods
  // ============================================

  /**
   * Check for pending transfers that are due for execution
   *
   * @param scheduledTransferPdas List of scheduled transfer PDAs to check
   * @returns List of pending transfers
   */
  async checkPendingTransfers(scheduledTransferPdas: PublicKey[]): Promise<PendingTransfer[]> {
    if (!this.tuktuk) {
      throw new Error("Tuk Tuk not initialized. Enable it during initialize()");
    }

    return this.tuktuk.checkPendingTransfers(scheduledTransferPdas);
  }

  /**
   * Manually execute a pending transfer
   * Use this when Tuk Tuk automation is not active
   *
   * @param transferId Transfer ID (PDA address as string)
   * @param executeTransferIx The execute_transfer instruction
   * @returns Transaction signature
   */
  async executePendingTransfer(
    transferId: string,
    executeTransferIx: TransactionInstruction
  ): Promise<{ tx: string }> {
    if (!this.tuktuk) {
      throw new Error("Tuk Tuk not initialized. Enable it during initialize()");
    }

    return this.tuktuk.executePendingTransfer(transferId, executeTransferIx);
  }

  // ============================================
  // Kamino Yield Methods
  // ============================================

  /**
   * Deposit to Kamino Lending for yield generation
   *
   * @param amount Amount in USDC
   * @returns Deposit result
   */
  async depositToKamino(amount: number): Promise<{ tx: string }> {
    if (!this.kamino) {
      throw new Error("Kamino not initialized. Enable it during initialize()");
    }

    const result = await this.kamino.depositToKamino(amount);
    return { tx: result.tx };
  }

  /**
   * Withdraw from Kamino Lending
   *
   * @param amount Amount in USDC
   * @returns Withdrawal result
   */
  async withdrawFromKamino(amount: number): Promise<{ tx: string }> {
    if (!this.kamino) {
      throw new Error("Kamino not initialized. Enable it during initialize()");
    }

    const result = await this.kamino.withdrawFromKamino(amount);
    return { tx: result.tx };
  }

  /**
   * Get detailed yield information from Kamino
   *
   * @returns Kamino yield info
   */
  async getKaminoYieldInfo(): Promise<KaminoYieldInfo> {
    if (!this.kamino) {
      throw new Error("Kamino not initialized. Enable it during initialize()");
    }

    return this.kamino.getKaminoYieldInfo();
  }

  // ============================================
  // Private helper methods
  // ============================================

  /**
   * Get user's share account
   */
  private async getUserShareAccount(): Promise<UserShare | null> {
    if (!this.program || !this.userCommitment) return null;

    try {
      const poolAddress = this.getShieldPoolAddress();
      const [userSharePda] = getUserSharePda(poolAddress, this.userCommitment, this.programId);
      const userShare = await (this.program.account as any).userShare.fetch(userSharePda);
      return userShare as UserShare;
    } catch {
      return null;
    }
  }

  /**
   * Get user's current shares (decrypted)
   */
  private async getUserShares(): Promise<bigint> {
    const userShare = await this.getUserShareAccount();
    if (!userShare) return 0n;

    // Read from placeholder encrypted share
    return readPlaceholderShares(new Uint8Array(userShare.encryptedShareAmount));
  }

  /**
   * Calculate shares to mint for a deposit
   */
  private calculateSharesForDeposit(
    depositAmount: BN,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalPoolValue.isZero() || totalShares.isZero()) {
      return BigInt(depositAmount.toString());
    }

    // shares = deposit * total_shares / total_pool_value
    const shares = depositAmount.mul(totalShares).div(totalPoolValue);
    return BigInt(shares.toString());
  }

  /**
   * Calculate shares to burn for a withdrawal
   */
  private calculateSharesForWithdrawal(
    withdrawalAmount: BN,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalPoolValue.isZero()) return 0n;

    // shares = withdrawal * total_shares / total_pool_value
    const shares = withdrawalAmount.mul(totalShares).div(totalPoolValue);
    return BigInt(shares.toString());
  }

  /**
   * Calculate the value of shares in USDC
   */
  private calculateShareValue(
    shares: bigint,
    totalPoolValue: BN,
    totalShares: BN
  ): bigint {
    if (totalShares.isZero()) return 0n;

    // value = shares * total_pool_value / total_shares
    const value = new BN(shares.toString()).mul(totalPoolValue).div(totalShares);
    return BigInt(value.toString());
  }
}

/**
 * Create a new SublyVaultClient instance
 *
 * @param connection - Solana RPC connection
 * @param wallet - User's wallet
 * @param config - Optional SDK configuration
 * @returns A new SublyVaultClient instance
 */
export function createSublyVaultClient(
  connection: Connection,
  wallet: Wallet,
  config?: VaultSdkConfig
): SublyVaultClient {
  return new SublyVaultClient(connection, wallet, PROGRAM_ID, config);
}
